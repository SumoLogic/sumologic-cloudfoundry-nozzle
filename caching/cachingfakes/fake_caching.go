// This file was generated by counterfeiter
package cachingfakes

import (
	"sync"
	"time"

	"github.com/SumoLogic/sumologic-cloudfoundry-nozzle/caching"
)

type FakeCaching struct {
	CreateBucketStub                  func()
	createBucketMutex                 sync.RWMutex
	createBucketArgsForCall           []struct{}
	PerformPoollingCachingStub        func(time.Duration)
	performPoollingCachingMutex       sync.RWMutex
	performPoollingCachingArgsForCall []struct {
		arg1 time.Duration
	}
	GetAppByGuidStub        func(string) []caching.App
	getAppByGuidMutex       sync.RWMutex
	getAppByGuidArgsForCall []struct {
		arg1 string
	}
	getAppByGuidReturns struct {
		result1 []caching.App
	}
	GetAllAppStub        func() []caching.App
	getAllAppMutex       sync.RWMutex
	getAllAppArgsForCall []struct{}
	getAllAppReturns     struct {
		result1 []caching.App
	}
	GetAppInfoStub        func(string) caching.App
	getAppInfoMutex       sync.RWMutex
	getAppInfoArgsForCall []struct {
		arg1 string
	}
	getAppInfoReturns struct {
		result1 caching.App
	}
	GetAppInfoCacheStub        func(string) caching.App
	getAppInfoCacheMutex       sync.RWMutex
	getAppInfoCacheArgsForCall []struct {
		arg1 string
	}
	getAppInfoCacheReturns struct {
		result1 caching.App
	}
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct{}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCaching) CreateBucket() {
	fake.createBucketMutex.Lock()
	fake.createBucketArgsForCall = append(fake.createBucketArgsForCall, struct{}{})
	fake.recordInvocation("CreateBucket", []interface{}{})
	fake.createBucketMutex.Unlock()
	if fake.CreateBucketStub != nil {
		fake.CreateBucketStub()
	}
}

func (fake *FakeCaching) CreateBucketCallCount() int {
	fake.createBucketMutex.RLock()
	defer fake.createBucketMutex.RUnlock()
	return len(fake.createBucketArgsForCall)
}

func (fake *FakeCaching) PerformPoollingCaching(arg1 time.Duration) {
	fake.performPoollingCachingMutex.Lock()
	fake.performPoollingCachingArgsForCall = append(fake.performPoollingCachingArgsForCall, struct {
		arg1 time.Duration
	}{arg1})
	fake.recordInvocation("PerformPoollingCaching", []interface{}{arg1})
	fake.performPoollingCachingMutex.Unlock()
	if fake.PerformPoollingCachingStub != nil {
		fake.PerformPoollingCachingStub(arg1)
	}
}

func (fake *FakeCaching) PerformPoollingCachingCallCount() int {
	fake.performPoollingCachingMutex.RLock()
	defer fake.performPoollingCachingMutex.RUnlock()
	return len(fake.performPoollingCachingArgsForCall)
}

func (fake *FakeCaching) PerformPoollingCachingArgsForCall(i int) time.Duration {
	fake.performPoollingCachingMutex.RLock()
	defer fake.performPoollingCachingMutex.RUnlock()
	return fake.performPoollingCachingArgsForCall[i].arg1
}

func (fake *FakeCaching) GetAppByGuid(arg1 string) []caching.App {
	fake.getAppByGuidMutex.Lock()
	fake.getAppByGuidArgsForCall = append(fake.getAppByGuidArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetAppByGuid", []interface{}{arg1})
	fake.getAppByGuidMutex.Unlock()
	if fake.GetAppByGuidStub != nil {
		return fake.GetAppByGuidStub(arg1)
	} else {
		return fake.getAppByGuidReturns.result1
	}
}

func (fake *FakeCaching) GetAppByGuidCallCount() int {
	fake.getAppByGuidMutex.RLock()
	defer fake.getAppByGuidMutex.RUnlock()
	return len(fake.getAppByGuidArgsForCall)
}

func (fake *FakeCaching) GetAppByGuidArgsForCall(i int) string {
	fake.getAppByGuidMutex.RLock()
	defer fake.getAppByGuidMutex.RUnlock()
	return fake.getAppByGuidArgsForCall[i].arg1
}

func (fake *FakeCaching) GetAppByGuidReturns(result1 []caching.App) {
	fake.GetAppByGuidStub = nil
	fake.getAppByGuidReturns = struct {
		result1 []caching.App
	}{result1}
}

func (fake *FakeCaching) GetAllApp() []caching.App {
	fake.getAllAppMutex.Lock()
	fake.getAllAppArgsForCall = append(fake.getAllAppArgsForCall, struct{}{})
	fake.recordInvocation("GetAllApp", []interface{}{})
	fake.getAllAppMutex.Unlock()
	if fake.GetAllAppStub != nil {
		return fake.GetAllAppStub()
	} else {
		return fake.getAllAppReturns.result1
	}
}

func (fake *FakeCaching) GetAllAppCallCount() int {
	fake.getAllAppMutex.RLock()
	defer fake.getAllAppMutex.RUnlock()
	return len(fake.getAllAppArgsForCall)
}

func (fake *FakeCaching) GetAllAppReturns(result1 []caching.App) {
	fake.GetAllAppStub = nil
	fake.getAllAppReturns = struct {
		result1 []caching.App
	}{result1}
}

func (fake *FakeCaching) GetAppInfo(arg1 string) caching.App {
	fake.getAppInfoMutex.Lock()
	fake.getAppInfoArgsForCall = append(fake.getAppInfoArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetAppInfo", []interface{}{arg1})
	fake.getAppInfoMutex.Unlock()
	if fake.GetAppInfoStub != nil {
		return fake.GetAppInfoStub(arg1)
	} else {
		return fake.getAppInfoReturns.result1
	}
}

func (fake *FakeCaching) GetAppInfoCallCount() int {
	fake.getAppInfoMutex.RLock()
	defer fake.getAppInfoMutex.RUnlock()
	return len(fake.getAppInfoArgsForCall)
}

func (fake *FakeCaching) GetAppInfoArgsForCall(i int) string {
	fake.getAppInfoMutex.RLock()
	defer fake.getAppInfoMutex.RUnlock()
	return fake.getAppInfoArgsForCall[i].arg1
}

func (fake *FakeCaching) GetAppInfoReturns(result1 caching.App) {
	fake.GetAppInfoStub = nil
	fake.getAppInfoReturns = struct {
		result1 caching.App
	}{result1}
}

func (fake *FakeCaching) GetAppInfoCache(arg1 string) caching.App {
	fake.getAppInfoCacheMutex.Lock()
	fake.getAppInfoCacheArgsForCall = append(fake.getAppInfoCacheArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetAppInfoCache", []interface{}{arg1})
	fake.getAppInfoCacheMutex.Unlock()
	if fake.GetAppInfoCacheStub != nil {
		return fake.GetAppInfoCacheStub(arg1)
	} else {
		return fake.getAppInfoCacheReturns.result1
	}
}

func (fake *FakeCaching) GetAppInfoCacheCallCount() int {
	fake.getAppInfoCacheMutex.RLock()
	defer fake.getAppInfoCacheMutex.RUnlock()
	return len(fake.getAppInfoCacheArgsForCall)
}

func (fake *FakeCaching) GetAppInfoCacheArgsForCall(i int) string {
	fake.getAppInfoCacheMutex.RLock()
	defer fake.getAppInfoCacheMutex.RUnlock()
	return fake.getAppInfoCacheArgsForCall[i].arg1
}

func (fake *FakeCaching) GetAppInfoCacheReturns(result1 caching.App) {
	fake.GetAppInfoCacheStub = nil
	fake.getAppInfoCacheReturns = struct {
		result1 caching.App
	}{result1}
}

func (fake *FakeCaching) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct{}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeCaching) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeCaching) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBucketMutex.RLock()
	defer fake.createBucketMutex.RUnlock()
	fake.performPoollingCachingMutex.RLock()
	defer fake.performPoollingCachingMutex.RUnlock()
	fake.getAppByGuidMutex.RLock()
	defer fake.getAppByGuidMutex.RUnlock()
	fake.getAllAppMutex.RLock()
	defer fake.getAllAppMutex.RUnlock()
	fake.getAppInfoMutex.RLock()
	defer fake.getAppInfoMutex.RUnlock()
	fake.getAppInfoCacheMutex.RLock()
	defer fake.getAppInfoCacheMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeCaching) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ caching.Caching = new(FakeCaching)
